<?php

namespace Minbaby\OpentracingTrift;

use Thrift\Protocol\TProtocol;
use Thrift\Protocol\TProtocolDecorator;
use Thrift\Type\TType;
use const Zipkin\Kind\CLIENT;
use const Zipkin\Kind\SERVER;
use Zipkin\Propagation\Map;
use Zipkin\Propagation\TraceContext;
use Zipkin\Span;
use Zipkin\Tracer;
use Zipkin\Tracing;
use Zipkin\TracingBuilder;

class SpanProtocol extends TProtocolDecorator
{
    /**
     * @var Tracing
     */
    protected $tracing;

    
    const SPAN_FIELD_ID = 3333;
    
    /**
     * @inheritdoc
     */
    protected function __construct(TProtocol $protocol, Tracing $tracing)
    {
        parent::__construct($protocol);
        $this->tracing = $tracing;
    }
    
    /**
     * @inheritdoc
     */
    public function writeMessageBegin($name, $type, $seqid)
    {
        $activeSpan = $this->tracing->getTracer()->newTrace();
        $activeSpan->setKind(CLIENT);
        
        SpanDecorator::decorate($activeSpan, $name, $type, $seqid);
        
        return parent::writeMessageBegin($name, $type, $seqid);
    }
    
    public function writeFieldStop()
    {
        $this->writeFieldBegin('span', TType::MAP, static::SPAN_FIELD_ID);
        
        $injector = $this->tracing->getPropagation()->getInjector(new Map());
    
        $data = [];
        $injector($this->tracing->getTracer()->getCurrentSpan()->getContext(), $data);
    
        $this->writeMapBegin(TType::STRING, TType::STRING, count($data));
        
        foreach ($data as $key => $val) {
            $this->writeString($key);
            $this->writeString($val);
        }
        
        $this->writeMapEnd();
        
        $this->writeFieldEnd();
        
        return parent::writeFieldStop(); // TODO: Change the autogenerated stub
    }
}
